package com.redhat.verticle;

import static com.redhat.helper.ActionHelper.created;
import static com.redhat.helper.ActionHelper.noContent;
import static com.redhat.helper.ActionHelper.ok;

import java.io.File;
import java.util.List;

import com.redhat.data.VertxBookRepository;
import com.redhat.pojo.Book;

import io.vertx.config.ConfigRetriever;
import io.vertx.core.AbstractVerticle;
import io.vertx.core.Future;
import io.vertx.core.Vertx;
import io.vertx.core.eventbus.EventBus;
import io.vertx.core.http.HttpServerOptions;
import io.vertx.core.http.HttpServerResponse;
import io.vertx.core.json.Json;
import io.vertx.core.json.JsonObject;
import io.vertx.core.logging.Logger;
import io.vertx.core.logging.LoggerFactory;
import io.vertx.core.logging.SLF4JLogDelegateFactory;
import io.vertx.core.shareddata.SharedData;
import io.vertx.ext.jdbc.JDBCClient;
import io.vertx.ext.sql.SQLConnection;
import io.vertx.ext.sql.SQLOptions;
import io.vertx.ext.web.Router;
import io.vertx.ext.web.RoutingContext;
import io.vertx.ext.web.handler.BodyHandler;
import io.vertx.ext.web.handler.StaticHandler;
import io.vertx.ext.web.handler.sockjs.BridgeOptions;
import io.vertx.ext.web.handler.sockjs.PermittedOptions;
import io.vertx.ext.web.handler.sockjs.SockJSHandler;

public class VertxMain extends AbstractVerticle {

	public VertxMain() {
		super();
		File logbackFile = new File("logback.xml");
		System.setProperty("logback.configurationFile", logbackFile.getAbsolutePath());
		System.setProperty(LoggerFactory.LOGGER_DELEGATE_FACTORY_CLASS_NAME, SLF4JLogDelegateFactory.class.getName());
		logger = LoggerFactory.getLogger(VertxMain.class);

		logger.info("Logger configured...");
	}

	protected Logger logger = null;
	private JDBCClient jdbc;
	private VertxBookRepository repository;

	public static void main(String[] args) {
		Vertx.vertx().deployVerticle(new VertxMain());
	}

	@Override
	public void start(Future<Void> fut) {
		repository = new VertxBookRepository(vertx);
		Router router = Router.router(vertx);

		router.route("/").handler(rc -> {
			HttpServerResponse response = rc.response();
			response.putHeader("content-type", "text/html").end("<pre><h1>Hello from my first Vert.x 3 app</h1></pre>");
		});

		router.route("/eventbus/*").handler(eventBusHandler());

		// Serve static resources from the /assets directory
		router.route("/assets/*").handler(StaticHandler.create("webroot"));
		router.route().handler(StaticHandler.create());

		// Rest API
		router.get("/api/books").handler(this::getAll);
		router.get("/api/books/:id").handler(this::getOne);
		router.route("/api/books*").handler(BodyHandler.create());
		router.post("/api/books").handler(this::addOne);
		router.delete("/api/books/:id").handler(this::deleteOne);
		router.put("/api/books/:id").handler(this::updateOne);

		router.get("/api/event").handler(this::publish);

		ConfigRetriever retriever = ConfigRetriever.create(vertx);
		ConfigRetriever.getConfigAsFuture(retriever).compose(config -> {
			jdbc = JDBCClient.createShared(vertx, config, "vertx_book");
			return connect().compose(connection -> {
				Future<Void> future = Future.future();
				createTableIfNeeded(connection).compose(this::createSomeDataIfNone).setHandler(x -> {
					connection.close();
					future.handle(x.mapEmpty());
				});
				return future;
			}).compose(v -> createHttpServer(config, router));

		}).setHandler(fut);
	}

	private Future<Void> createHttpServer(JsonObject config, Router router) {
		Future<Void> future = Future.future();
		Integer port = config.getInteger("HTTP_PORT", 8080);
		vertx.createHttpServer(new HttpServerOptions().setSsl(false)).requestHandler(router::accept).listen(port,
				res -> {
					if (res.succeeded()) {
						logger.info("Server listening at: http://localhost:" + port);
						future.handle(res.mapEmpty());
					} else {
						logger.error("Server start fail");
						future.fail(res.cause());
					}
				}

		);
		return future;
	}

	private Future<SQLConnection> connect() {
		Future<SQLConnection> future = Future.future();
		jdbc.getConnection(ar -> future.handle(ar.map(c -> c.setOptions(new SQLOptions().setAutoGeneratedKeys(true)))));
		return future;
	}

	// ---- HTTP Actions ----

	private void getAll(RoutingContext rc) {
		connect().compose(this::query).setHandler(ok(rc));
	}

	private void addOne(RoutingContext rc) {
		Book book = rc.getBodyAsJson().mapTo(Book.class);
		connect().compose(connection -> insert(connection, book, true)).setHandler(created(rc));
	}

	private void deleteOne(RoutingContext rc) {
		String id = rc.pathParam("id");
		connect().compose(connection -> delete(connection, id)).setHandler(noContent(rc));
	}

	private void getOne(RoutingContext rc) {
		String id = rc.pathParam("id");
		connect().compose(connection -> queryOne(connection, id)).setHandler(ok(rc));
	}

	private void updateOne(RoutingContext rc) {
		String id = rc.request().getParam("id");
		Book book = rc.getBodyAsJson().mapTo(Book.class);
		connect().compose(connection -> update(connection, id, book)).setHandler(noContent(rc));
	}

	// websocket
	private SockJSHandler eventBusHandler() {
		BridgeOptions options = new BridgeOptions().addOutboundPermitted(new PermittedOptions().setAddressRegex("out"))
				.addInboundPermitted(new PermittedOptions().setAddressRegex("in"));

		SharedData data = vertx.sharedData();
		EventBus eventBus = vertx.eventBus();

		SockJSHandler sockJSHandler = SockJSHandler.create(vertx);
		return sockJSHandler.bridge(options, new VertxWebSocketHandler(eventBus));
	}

	private void publish(RoutingContext rc) {

		rc.response().putHeader("content-type", "application/json; charset=utf-8").end(Json.encodePrettily("ok"));
		Book book = new Book("titulo", "url", "author");
		JsonObject bookJson = new JsonObject(Json.encode(book));
		vertx.eventBus().publish("out", bookJson);
	}

// delegate methods //
	public Future<SQLConnection> createTableIfNeeded(SQLConnection connection) {
		return repository.createTableIfNeeded(connection);
	}

	public Future<SQLConnection> createSomeDataIfNone(SQLConnection connection) {
		return repository.createSomeDataIfNone(connection);
	}

	public Future<List<Book>> query(SQLConnection connection) {
		return repository.query(connection);
	}

	public Future<Book> insert(SQLConnection connection, Book book, boolean closeConnection) {
		return repository.insert(connection, book, closeConnection);
	}

	public Future<Book> queryOne(SQLConnection connection, String id) {
		return repository.queryOne(connection, id);
	}

	public Future<Void> delete(SQLConnection connection, String id) {
		return repository.delete(connection, id);
	}

	public Future<Void> update(SQLConnection connection, String id, Book book) {
		return repository.update(connection, id, book);
	}

}
